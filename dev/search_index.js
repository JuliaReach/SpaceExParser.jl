var documenterSearchIndex = {"docs":
[{"location":"lib/methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"lib/methods/","page":"Methods","title":"Methods","text":"This section describes systems methods implemented in SpaceExParser.jl.","category":"page"},{"location":"lib/methods/","page":"Methods","title":"Methods","text":"Pages = [\"methods.md\"]\nDepth = 3","category":"page"},{"location":"lib/methods/#Input/Output","page":"Methods","title":"Input/Output","text":"","category":"section"},{"location":"lib/methods/#SpaceExParser.readsxmodel","page":"Methods","title":"SpaceExParser.readsxmodel","text":"readsxmodel(file; [raw_dict]=false, [ST]=nothing, [kwargs]...)\n\nRead a SpaceEx model file.\n\nInput\n\nfile      – the filename of the SpaceEx file (in XML format)\nraw_dict  – (optional, default: false) if true, return the raw dictionary with                the objects that define the model (see Output below), without                actually returning a HybridSystem; otherwise, instantiate a                HybridSystem with the given assumptions\nST        – (optional, default: nothing) assumption for the type of                system for each mode\n\nOutput\n\nHybrid system that corresponds to the given SpaceEx model and the given assumptions on the system type if raw_dict=true; otherwise, a dictionary with the Julia expression objects that define the model. The keys of this dictionary are:\n\nautomaton\nvariables\ntransitionlabels\ninvariants\nflows\nassignments\nguards\nswitchings\nnlocations\nntransitions\n\nNotes\n\nCurrently, this function makes the following assumptions:\n\nThe model contains only 1 component. If the model contains more than 1 component, an error is raised. In this case, recall that network components can be flattened using sspaceex.\nThe default and a custom ST parameter assume that all modes are of the same type. In general, you may pass a vector of system's types in kwargs (not implemented).\n\nMoreover, let us note that:\n\nThe tags `<notes> ... <\n\notes>` are ignored.\n\nVariable names are stored in the dictionary variables, together with other information such as if the variable is controlled or not. This dictionary is then stored in the extension field (ext) of the hybrid system.\nThe transition labels are stored in the extension field (ext) of the hybrid system.\nWe use the location \"id\" field (an integer), such that each of the vectors modes, resetmaps and switchings corresponds to the location with the given \"id\". For example, modes[1] corresponds to the mode for the location with id=\"1\".\nThe name field of a location is ignored.\nThe nature of the switchings is autonomous. If there are guards, these define state-dependent switchings only. Switching control functions are not yet implemented.\nThe resetmaps field consists of the vector of tuples (assignment, guard), for each location.\n\nThese comments apply whenever raw_dict=false:\n\nThe field variables is an ordered dictionary, where the order is given by the insertion order. This allows deterministic iteration over the dictionary, (notice that in a usual dictionary, the order in which the elements are returned does not correspond, in general, to the order in which the symbols were saved). The variables are stored in the coefficients matrix using this insertion order.\nIf ST is nothing, the modes are given as the vector of tuples (flows, invariants), each component being a list of expressions, and similarly the reset maps are the vector of tuples (assignments, guards).\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.linearHS","page":"Methods","title":"SpaceExParser.linearHS","text":"linearHS(HDict; ST=ConstrainedLinearControlContinuousSystem,\n         STD=ConstrainedLinearControlDiscreteSystem,\n         kwargs...)\n\nConvert the given hybrid-system object into a concrete system type for each mode, and convert Julia expressions into SymEngine symbolic expressions.\n\nInput\n\nHDict – raw dictionary of hybrid system objects\nST    – (optional, default: ConstrainedLinearControlContinuousSystem)            assumption for the type of mathematical system for each mode\nSTD   – (optional, default: ConstrainedLinearControlDiscreteSystem)             assumption for the type of mathematical system for the assignments and guards\n\nOutput\n\nThe tuple (modes, resetmaps).\n\nNotes\n\n\"Controlled\" variables are interpreted as state variables (there is an ODE flow  for them), otherwise these are interpreted as input variables (there is not an  ODE for them).\nIf the system has nonlinearities, then some first order derivatives cannot be evaluated to numbers, and this function does not apply. In that case, you will see the error message: ArgumentError: symbolic value cannot be evaluated to a numeric value.\nWe assume that inequalities in invariants are of the form ax <= b or ax >= b, where b is a scalar value. Other combinations are NOT yet supported.\nIn inequalities, x is a vector of variables of two different types only: either all of them are state variables, or all of them are input variables. Other combinations are not yet allowed.\nStrict and non-strict inequalities are treated as being the same: both are mapped to half-spaces.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Parsing-the-SpaceExParser-language","page":"Methods","title":"Parsing the SpaceExParser language","text":"","category":"section"},{"location":"lib/methods/#SpaceExParser.count_locations_and_transitions","page":"Methods","title":"SpaceExParser.count_locations_and_transitions","text":"count_locations_and_transitions(root_sxmodel)\n\nReturns the number of locations and transitions for each component.\n\nInput\n\nroot_sxmodel – the root element of a SpaceEx file\n\nOutput\n\nTwo vectors of integers (lcount, tcount), where the i-th entry of lcount and tcount are the number of locations and transitions, respectively, of the i-th component.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.parse_sxmath","page":"Methods","title":"SpaceExParser.parse_sxmath","text":"parse_sxmath(s; assignment=false)\n\nReturns the list of expressions corresponding to a given SpaceExParser string.\n\nInput\n\ns          – string\nassignment – (optional, default: false)\n\nOutput\n\nVector of expressions, equations or inequalities.\n\nExamples\n\njulia> using SpaceExParser: parse_sxmath\n\njulia> parse_sxmath(\"x >= 0\")\n1-element Vector{Expr}:\n :(x >= 0)\n\njulia> parse_sxmath(\"x' == x & v' == -0.75*v\")\n2-element Vector{Expr}:\n :(x' = x)\n :(v' = -0.75v)\n\njulia> parse_sxmath(\"x == 0 & v <= 0\")\n2-element Vector{Expr}:\n :(x = 0)\n :(v <= 0)\n\nParentheses are ignored:\n\njulia> parse_sxmath(\"(x == 0) & (v <= 0)\")\n2-element Vector{Expr}:\n :(x = 0)\n :(v <= 0)\n\nSplitting is also performend over double ampersand symbols:\n\njulia> parse_sxmath(\"x == 0 && v <= 0\")\n2-element Vector{Expr}:\n :(x = 0)\n :(v <= 0)\n\nIf you want to parse an assignment, use the assignment flag:\n\njulia> parse_sxmath(\"x := -x*0.1\", assignment=true)\n1-element Vector{Expr}:\n :(x = -x * 0.1)\n\nCheck that we can parse expressions involving parentheses:\n\njulia> parse_sxmath(\"(t <= 125 & y>= -100)\")\n2-element Vector{Expr}:\n :(t <= 125)\n :(y >= -100)\njulia> parse_sxmath(\"t <= 125 & (y>= -100)\")\n2-element Vector{Expr}:\n :(t <= 125)\n :(y >= -100)\n\nAlgorithm\n\nFirst a sanity check (assertion) is made that the expression makes a coherent use of parentheses.\n\nThen, the following steps are done (in the given order):\n\nsplit the string with the & key, or &&\nremove trailing whitespace of each substring\nreplace double == with single =\ndetect unbalanced parentheses (beginning and final subexpressions) and in that case delete them\ncast to a Julia expression with parse\n\nNotes\n\nFor assignments, the nomenclature := is also valid and here it is replaced to =, but you need to set assignment=true for this replacement to take effect.\n\nThe characters '(' and ')' are deleted (replaced by the empty character), whenever it is found that there are unbalanced parentheses after the expression is split into subexpressions.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.parse_sxmodel!","page":"Methods","title":"SpaceExParser.parse_sxmodel!","text":"parse_sxmodel!(root_sxmodel, HDict)\n\nInput\n\nroot_sxmodel – root element of an XML document\nHDict        – dictionary that wraps the hybrid model and contains the keys                   (automaton, variables, transitionlabels, invariants, flows,                   assignments, guards, switchings, nlocations, ntransitions)\n\nOutput\n\nThe HDict dictionary.\n\nNotes\n\nEdge labels are not used and their symbol is (arbitrarily) set to the integer 1.\nLocation identifications (\"id\" field) are assumed to be integers.\nThe switchings types are assumed to be autonomous. See Switching in Systems and Control, D. Liberzon, for further details on the classification of switchings.\nWe add fresh variables for each component (id_variable += 1). In general variables can be shared among components if the bindings are defined. Currently, we make the simplifying assumption that the model has only one component and we don't take bindings into account.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.add_variable!","page":"Methods","title":"SpaceExParser.add_variable!","text":"add_variable!(variables, field, id=1)\n\nInput\n\nvariables – vector of symbolic variables\nfield     – an EzXML.Node node with containing information about a param field\nid        – (optional, default: 1) integer that identifies the variable\n\nOutput\n\nThe updated vector of symbolic variables.\n\nNotes\n\nParameters can be either variable names (type \"real\") or labels (type \"label\").\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.add_transition_label!","page":"Methods","title":"SpaceExParser.add_transition_label!","text":"add_transition_label!(labels, field)\n\nInput\n\nlabels – vector of transition labels\nfield  – node with a param label field\n\nOutput\n\nThe updated vector of transition labels.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.parse_location","page":"Methods","title":"SpaceExParser.parse_location","text":"parse_location(field)\n\nInput\n\nfield  – location node\n\nOutput\n\nThe tuple (id, invariant, flow) where:\n\nid is the integer that identifies the location,\ninvariant is the list of subexpressions that determine that invariant for this location,\nflow is the list of ODEs that define the flow for this location.\n\nBoth the invariant and the flow are vectors of symbolic expressions Expr.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#SpaceExParser.parse_transition","page":"Methods","title":"SpaceExParser.parse_transition","text":"parse_transition(field)\n\nInput\n\nfield  – transition node\n\nOutput\n\nThe tuple (q, r, G, A) where q and r are the source mode and target mode respectively for this transition, G is the list of guards for this transition, and A is the list of assignments. G and A are vectors of symbolic expressions Expr.\n\nNotes\n\nIt is assumed that the \"source\" and \"target\" fields can be cast to integers.\n\nIt can happen that the given transition does not contain the \"guard\" field (or the \"assignment\", or both); in that case this function returns an empty of expressions for those cases.\n\n\n\n\n\n","category":"function"},{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"If you like this package, consider contributing!","category":"page"},{"location":"about/","page":"About","title":"About","text":"Creating an issue in the GitHub issue tracker to report a bug, open a discussion about existing functionality, or suggesting new functionality is appreciated.","category":"page"},{"location":"about/","page":"About","title":"About","text":"If you have written code and would like it to be peer reviewed and added to the library, you can fork the repository and send a pull request (see below). Typical contributions include fixing a bug, adding a new feature or improving the documentation (either in source code or the online manual).","category":"page"},{"location":"about/","page":"About","title":"About","text":"Below we detail some general comments about contributing to this package. The JuliaReach Developer's Documentation describes coding guidelines; take a look when in doubt about the coding style that is expected for the code that is finally merged into the library.","category":"page"},{"location":"about/#Branches","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g. mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This project is synchronized with GitHub Actions such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to make all unit tests pass.","category":"page"},{"location":"about/","page":"About","title":"About","text":"To run the unit tests locally, you can do:","category":"page"},{"location":"about/","page":"About","title":"About","text":"julia> using Pkg\n\njulia> Pkg.test(\"SpaceExParser\")","category":"page"},{"location":"about/","page":"About","title":"About","text":"We also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"page"},{"location":"about/#Contributing-to-the-documentation","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the docs, run make.jl:","category":"page"},{"location":"about/","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/#Credits","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/","page":"About","title":"About","text":"These persons have contributed to SpaceExParser.jl (in alphabetic order):","category":"page"},{"location":"about/","page":"About","title":"About","text":"Marcelo Forets\nNikos Kekatos\nChristian Schilling","category":"page"},{"location":"examples/examples/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"The folder /examples contains a collection of model files that are available from different sources:","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"SpaceEx webpage, small selection of examples that is part of the VM Server distribution and can be executed directly from the SpaceEx web interface.","category":"page"},{"location":"examples/examples/#Remarks","page":"Introduction","title":"Remarks","text":"","category":"section"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"The examples consist of single hybrid automata that are constructed via flattening (parallel composition). This can be done via SpaceEx executable file with the command","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"spaceex -g name.cfg -m name.xml --output-system-file new_name.xml","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"However, note that the flattening process changes the original model and may induce parsing errors. The parsing errors only appear when the constructed model is visualized/analyzed with the Model Editor or/and the Web Interface. There are no parsing errors with the source code/executable SpaceEx. A list of identified parsing problems follows below.","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"Special symbols, e.g. ~, _ in the variable and location names\nSpecial characters, e.g. Greek or Russian letters\nNondeterministic flows, e.g. x'==x+w1, where 0<w1<0.1 (see bball_nondet)\nNondeterministic resets, e.g. v' == -0.75*v+w2 (see bball_nondet)\nNaming issues, e.g. default variable name is component.subcomponent.variable","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"The aforementioned problems would yield errors/warnings when parsed.","category":"page"},{"location":"examples/examples/","page":"Introduction","title":"Introduction","text":"1. ERROR | in component 'osc_w_4th_order' the string 'osc.osci.hop'\ndoesn't match NAME pattern [a-zA-Z_][a-zA-Z0-9_]* >>> element\nlabel removed\n\n2. Error: name=\"pp-always-always-always-always\" value doesn't match\nNAME pattern [a-zA-Z_][a-zA-Z0-9_]*>>> set to default: \"unnamed\"\n\n3. ERROR |  new LOCATION with name= 'unnamed'; name already exist,\nrenamed in 'unnamed2'\n\n4. ERROR: Failed to parse model file phpxbMjAb.xml.\ncaused by: Could not parse base component system.\ncaused by: Failed to parse flow of location always.\ncaused by: Could not parse predicate\n\n5. Constructed Reset: x' == x & v' == -0.75*v with offset\nsupport_function ( w1 >= -0.0499999 & w1 <= 0.0499999 &\nw2 >= -0.0999999 & w2 <= 0.0999999, mapped by x' == 0 & v' == w2 )\n\n6. Constructed Flow:  x' == v & v' == -0.999999 with offset\nsupport_function(x >= 0 & SLACK2 <= 0.0999999 & SLACK2 >= 0 &\nSLACK4 <= 0.199999 & SLACK4 >= 0, mapped by x' == 0 & v' == -SLACK2+0.0499999 )","category":"page"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"This section describes systems types implemented in SpaceExParser.jl.","category":"page"},{"location":"lib/types/","page":"Types","title":"Types","text":"Pages = [\"types.md\"]\nDepth = 3","category":"page"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"S. Cotton, G. Frehse and O. Lebeltel. The SpaceEx modeling language (2010).\n\n\n\nG. Frehse. An Introduction to SpaceEx v0.8 (2010).\n\n\n\n","category":"page"},{"location":"#SpaceExParser.jl","page":"Home","title":"SpaceExParser.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SpaceExParser is a Julia package to read SpaceEx model files.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SpaceEx modeling language (SpaceExParser) is a format for the mathematical description of hybrid dynamical systems. It has been described in Cotton et al. [CFL10]. See also Frehse [Fre10].","category":"page"},{"location":"","page":"Home","title":"Home","text":"A visual model editor is available for download on the SpaceEx website. See the examples in this documentation for screenshots and further details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The aim of this library is to read SpaceEx model files and transform them into Julia objects, for their inspection and analysis, such as reachability computations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parse SpaceEx files into types defined in Julia packages HybridSystems.jl and MathematicalSystems.jl.\nCan read arbitrary ODEs, eg. non-linear dynamics in the ODE flow for each mode.","category":"page"},{"location":"#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"lib/types.md\",\n    \"lib/methods.md\"\n]\nDepth = 2","category":"page"},{"location":"examples/bball/#Bouncing-ball","page":"Bouncing ball","title":"Bouncing ball","text":"","category":"section"},{"location":"examples/bball/","page":"Bouncing ball","title":"Bouncing ball","text":"Pages = [\"bball.md\"]\nDepth = 3","category":"page"},{"location":"examples/bball/","page":"Bouncing ball","title":"Bouncing ball","text":"(Image: Bouncing ball model)","category":"page"}]
}
